import _ from "lodash";
import { getGridObj } from "./shuffle";

export default class Room {
  intialBoard = {};

  constructor(id) {
    this.id = id;
    this.users = {};
    this.start = false;
    this.intialBoard = getGridObj();
    this.gameOver = false;
    this.won = false;
    this.gameWinner = "";
  }

  canEmit() {
    return _.size(this.users) == 2;
  }

  addUser(io, { username, id }) {
    if (_.keys(this.users).length === 2) return;
    let userObj = {
      id,
      username,
      could_be_won: true,
      time: 0,
      solving: false,
      won: false,
    };
    userObj = { ...userObj, ...this.intialBoard };
    this.users[id] = userObj;
    this.updateUser(io, id, {});
  }

  updateUser(io, id, payload) {
    this.users[id] = { ...this.users[id], ...payload };
    if (this.canEmit() || this.start) {
      const users = _.values(this.users);
      if (!this.start) {
        //update user board
        users.map((obj) => {
          obj = { ...obj, ...this.intialBoard };
        });
        console.log(JSON.parse(JSON.stringify(this)));
        this.start = true;
        io.to(this.id).emit("initGame", JSON.parse(JSON.stringify(this)));
        console.log("emitgame");
      }
      //calculate global state
      if (users.some((obj) => obj.won)) this.won = true;
      //send update through socket
      io.to(this.id).emit("updateObj", this);
      //calculate gameOver and winner
      //what if one user left the game
    }
  }

  deleteUser(id) {
    if (_.has(this.users, id)) {
      this.users = _.omit(this.users, id);
    }
  }

  isGameOver() {
    return false;
  }
}
